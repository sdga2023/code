<script>
  import { _ } from 'svelte-i18n';
  import { referenceCountry } from '$lib/stores/referenceCountry.js';
  import * as topojson from 'topojson-client';
  import { geoEqualEarth, geoPath } from 'd3';
  import * as Colors from '$lib/styles/tokens.es6.js';
  import Tooltip from '$lib/components/general/Tooltip.svelte';
  import Lens from '../general/Lens.svelte';
  import { fade } from 'svelte/transition';

  import countriesJSON from '../../../data/other/wb_countries_topo.json';
  import disputedJSON from '../../../data/other/wb_disputed_areas_topo.json';
  import centroidsJSON from '../../../data/other/country_centroids.json';

  export let data;
  export let activeScene;
  export let vulnerability;
  export let readiness;
  export let low;
  export let medium;
  export let high;
  export let parentWidth;
  export let parentHeight;

  export let lowlow
  export let intermediatelow
  export let highlow
  export let lowintermediate
  export let intermediateintermediate
  export let highintermediate
  export let lowhigh
  export let intermediatehigh
  export let highhigh

  const classMap = {
    low: low,
    medium: medium,
    high: high
  };

  $: mapWidth = parentWidth > (parentHeight - 136) * 1.7 ? (parentHeight - 136) * 1.7 : parentWidth;
  $: mapHeight = parentWidth > (parentHeight - 136) * 1.7 ? parentHeight - 136 : parentWidth / 1.7;

  const colorScale = [
    { key: '1-1', label: lowlow, colour: '#d7d7da' },
    { key: '2-1', label: intermediatelow, colour: '#d9887f' },
    { key: '3-1', label: highlow, colour: '#c32b2b' },
    { key: '1-2', label: lowintermediate, colour: '#97bec1' },
    { key: '2-2', label: intermediateintermediate, colour: '#997870' },
    { key: '3-2', label: highintermediate, colour: '#8a2626' },
    { key: '1-3', label: lowhigh, colour: '#4da5a7' },
    { key: '2-3', label: intermediatehigh, colour: '#4e6861' },
    { key: '3-3', label: highhigh, colour: '#462121' }
  ];

  /*const colorScale = [
      { key: '1-1', label: 'Low vulnerability, low readiness', colour: "#d3d3d3" },
      { key: '2-1', label: '', colour: "#ba8890" },
      { key: '3-1', label: 'High vulnerability, low readiness', colour: "#9e3547" },
      { key: '1-2', label: '', colour: "#8aa6c2" },
      { key: '2-2', label: '', colour: "#7a6b84" },
      { key: '3-2', label: '', colour: "#682a41" },
      { key: '1-3', label: 'Low vulnerability, high readiness', colour: "#4279b0" },
      { key: '2-3', label: '', colour: "#3a4e78" },
      { key: '3-3', label: 'High vulnerability, high readiness', colour: "#311e3b" }
    ];*/

  let disputed = topojson.feature(disputedJSON, disputedJSON.objects.wb_disputed_areas).features;
  let centroids = centroidsJSON.features;

  $: countries = topojson.feature(countriesJSON, countriesJSON.objects.wb_countries).features.map((c) => {
    const iso3 = c.properties.ISO_A3;
    let countryData = data?.find((c) => c.iso3c === iso3);

    const centroid = centroids?.find((c) => c.properties.iso_3c === iso3)?.geometry.coordinates;

    let fill = Colors.ColorVisNotAvailable;
    if (countryData) {
      const datum = countryData['bi_class'];
      fill = colorScale.find((d) => d.key == datum).colour;
    }
    //const stroke = color(fill).darker(1);
    const stroke = '#FFFFFF';
    return { ...c, fill, stroke, centroid, data: countryData };
  });

  const globeOffset = 0;

  $: projection = geoEqualEarth().fitExtent(
    [
      [globeOffset, globeOffset],
      [mapWidth - globeOffset, mapHeight - globeOffset]
    ],
    { type: 'Sphere' }
  );

  let mousePos;
  function updateMouse(evt) {
    mousePos = { x: evt.clientX, y: evt.clientY };
  }

  let currentCountry;
  $: currentCountryData = currentCountry ? countries.find((c) => c.properties.ISO_A3 === currentCountry) : null;
  
  $: activeCountryBBox = activeScene.id != 'intro' ? geoPath().projection(projection).bounds(countries.find((c) => c.properties.ISO_A3 === activeScene.id)) : null;
  $: activeCentroid = activeCountryBBox
    ? {
        x: (activeCountryBBox[0][0]) + (activeCountryBBox[1][0] - activeCountryBBox[0][0])/2,
        y: (activeCountryBBox[0][1]) + (activeCountryBBox[1][1] - activeCountryBBox[0][1])/2,
        r: Math.max(activeCountryBBox[1][0] - activeCountryBBox[0][0], activeCountryBBox[1][1] - activeCountryBBox[0][1])/2 + 6,
        iso3c: activeScene.id
      }
    : null;
  
  let refCountry;

  $: if (countries && $referenceCountry) {
    refCountry = countries.find((c) => c.properties.ISO_A3 === $referenceCountry);
    const projected = projection(refCountry.centroid);
    refCountry.projected = { x: projected[0], y: projected[1] };
  } else {
    refCountry = null;
  }

  //$: activeCentroid = centroids.find((d) => d.properties.iso_3c == activeScene.id) ? centroids.find((d) => d.properties.iso_3c == activeScene.id) : null;

  const legendItemWidth = 20;
</script>

<div>
  <svg width={parentWidth} height={parentHeight} on:mousemove={updateMouse}>
    <defs>
      <marker id="arrowhead" markerWidth="5" markerHeight="6" refX="4" refY="3" orient="auto">
        <polygon points="0 0, 5 3, 0 6" fill={'black'} stroke="black" stroke-width={0} />
      </marker>
    </defs>
    <g class="legend" transform={`translate(${parentWidth / 2 - 40}, ${50}) rotate(-45)`}>
      {#each colorScale as item, i}
        <rect
          x={parseInt(item.key.substring(0, 1) - 1) * legendItemWidth}
          y={parseInt(item.key.substring(2, 3) - 1) * legendItemWidth}
          width={legendItemWidth}
          height={legendItemWidth}
          fill={item.colour}
          stroke={'white'}
          stroke-width={0.5}
        />
      {/each}
      <line x1={-8} x2={-8} y1={0} y2={3 * legendItemWidth} stroke="black" stroke-width={1} marker-end={'url(#arrowhead)'} />
      <line x1={0} x2={3 * legendItemWidth} y1={-8} y2={-8} stroke="black" stroke-width={1} marker-end={'url(#arrowhead)'} />
      <text x={1.5 * legendItemWidth} class="small" y={-16} transform="rotate(0)" text-anchor="middle">{vulnerability}</text>
      <text x={1.5 * legendItemWidth} class="small" transform="rotate(90)" y={24} text-anchor="middle">{readiness}</text>
    </g>
    <g class="map" transform={`translate(${parentWidth / 2 - mapWidth / 2}, 120)`}>
      {#if countries && projection}
        {#each countries as country}
          <path
            d={geoPath().projection(projection)(country)}
            fill={country.fill}
            stroke={country.stroke}
            stroke-width={0.5}
            opacity={!activeCentroid || country.properties.ISO_A3 == activeCentroid.iso3c ? 1 : 0.2 }
            on:mouseover={() => (currentCountry = country.properties.ISO_A3)}
            on:focus={() => (currentCountry = country.properties.ISO_A3)}
            on:mouseout={() => (currentCountry = null)}
            on:blur={() => (currentCountry = null)}
          />
        {/each}

        {#if refCountry}
          <path
            d={geoPath().projection(projection)(refCountry)}
            fill="transparent"
            stroke={Colors.ColorReferenceCountry}
            stroke-width={4}
            on:mouseover={() => (currentCountry = refCountry.properties.ISO_A3)}
            on:focus={() => (currentCountry = refCountry.properties.ISO_A3)}
            on:mouseout={() => (currentCountry = null)}
            on:blur={() => (currentCountry = null)}
          />
          <path
            d={geoPath().projection(projection)(refCountry)}
            fill={refCountry.fill}
            stroke={'#FFFFFF'}
            stroke-width={0.5}
            on:mouseover={() => (currentCountry = refCountry.properties.ISO_A3)}
            on:focus={() => (currentCountry = refCountry.properties.ISO_A3)}
            on:mouseout={() => (currentCountry = null)}
            on:blur={() => (currentCountry = null)}
          />
          <text class="reference-label" x={refCountry.projected.x} y={refCountry.projected.y} text-anchor="middle"
            >{$_(`country.${refCountry.properties.ISO_A3.toLowerCase()}`)}</text
          >
          <text class="reference-label small" x={refCountry.projected.x} y={refCountry.projected.y + 20} text-anchor="middle">
            {refCountry.data ? colorScale.find(d => d.key == refCountry.data['bi_class']).label : 'No data'}
          </text>
        {/if}

        {#if disputed}
          {#each disputed as disp}
            <path d={geoPath().projection(projection)(disp)} fill="var(--color-vis-not-available)" stroke="#FFFFFF" stroke-width={0.5} />
          {/each}
        {/if}

        {#if currentCountryData}
          <path
            d={geoPath().projection(projection)(currentCountryData)}
            fill="transparent"
            stroke={'#000000'}
            stroke-width={3}
            class="hover-outline"
          />
        {/if}
      {/if}
      {#if activeCentroid}
        <Lens
          x={activeCentroid.x}
          y={activeCentroid.y}
          r={activeCentroid.r} />
        <text
          x={activeCentroid.x}
          y={activeCentroid.y - activeCentroid.r - 6}
          text-anchor={'middle'}
          class={'geo'}
          transition:fade|local>{$_(`country.${activeCentroid.iso3c.toLowerCase()}`)}</text
        >
      {/if}
    </g>
  </svg>

  {#if currentCountry && mousePos}
    <Tooltip visible={true} targetPos={mousePos}>
      <p class="label caps">{$_(`country.${currentCountry?.toLowerCase()}`)}</p>
      <p class="label stronger">
        {data.find((c) => c.iso3c === currentCountry)
          ? classMap[data.find((c) => c.iso3c === currentCountry)['vulnerability_class']]
          : 'No data'}
      </p>
      <p class="label small weaker">{vulnerability}</p>
      <p class="label stronger">
        {data.find((c) => c.iso3c === currentCountry)
          ? classMap[data.find((c) => c.iso3c === currentCountry)['readiness_class']]
          : 'No data'}
      </p>
      <p class="label small weaker">{readiness}</p>
    </Tooltip>
  {/if}
</div>

<style>
  .hover-outline {
    pointer-events: none;
  }
  .legend {
    transform-box: fill-box;
    transform-origin: center;
  }
  path {
    transition: opacity 0.5s;
  }
</style>
